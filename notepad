threads
mutex
semaphores
shared memories
"waiters"


NO deadlock
NO dataraces

*eating
*thinking
*sleeping

//while eating, they dont think nor sleep
//while thinking, they dont sleep nor eat
//while sleeping, they dont eat nor think

large bowl of spaghetti in the middle of the table
Philosophers take turn eating, thinking and sleeping
Philosophers require two forks to eat (left & right)
They cannot die

** == in miliseconds

./philosophers "number_of_philosophers"  "time_to_die**"  "time_to_eat**"  "time_to_sleep**"  "number_of_times_each_philo_must_eat(optional)"

Each philo must have a ID number ranging from 1 to number_of_philosophers.

Philosopher 1 sits next to the next number_of_philosophers.
Any other philosopher, numbered N, sits between philosopher N - 1 and philosopher N + 1.

=====logs=====

timestamp_in_ms X has taken a fork
timestamp_in_ms X is eating
timestamp_in_ms X is sleeping
timestamp_in_ms X is thinking
timestamp_in_ms X died

displayed state message shouldn't overlap with another message
a message announcing a philo's death must be displayed within 10 sm of their actual death


=====functions=====
memset
printf
gettimeofday
pthread_create
pthread_detach
pthread_join
pthread_mutex_init
pthread_mutex_destroy
pthread_mutex_lock
pthread_mutex_unlock

no libft

Each philosopher must be represented as a separate thread

There is one fork between each pair of philosophers. Therefore, if there are seveeral philosophers, each philosopher has a fork on their left side and a fork on their right side. If there is only one philosopher, they will have access to just one fork.

To prevent philosophers from duplicating forks, you should protect each fork's state with a mutex.


*inits
*waiters
*routines
*actions (grab & drop forks)
*gettimeofday


pthread_mutex_t	mutex;

void variable()
{
	pthread_mutex_lock(&forks[left])
	pthread_mutex_lock(&forks[right])
================ACTION================
	pthread_mutex_unlock(&forks[left])
	pthread_mutex_unlock(&forks[right])
}

{
	pthread_t	p1;
	pthread_mutex_init(&mutex, NULL);
	while (i < n; i++)
	{
		if (pthread_create(&p1, NULL, &variable, NULL) != 0)
			return (1);
	}
	while (i < n; i++)
	{
		if (pthread_join(p1, NULL) != 0)
			return (2);
	}
	pthread_mutex_destroy(&mutex);
}

shared resource == mutex

